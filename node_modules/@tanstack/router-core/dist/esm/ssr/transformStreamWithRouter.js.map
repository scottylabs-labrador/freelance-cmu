{"version":3,"file":"transformStreamWithRouter.js","sources":["../../../src/ssr/transformStreamWithRouter.ts"],"sourcesContent":["import { ReadableStream } from 'node:stream/web'\nimport { Readable } from 'node:stream'\nimport { createControlledPromise } from '../utils'\nimport type { AnyRouter } from '../router'\n\nexport function transformReadableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: ReadableStream,\n) {\n  return transformStreamWithRouter(router, routerStream)\n}\n\nexport function transformPipeableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: Readable,\n) {\n  return Readable.fromWeb(\n    transformStreamWithRouter(router, Readable.toWeb(routerStream)),\n  )\n}\n\n// regex pattern for matching closing body and html tags\nconst patternBodyStart = /(<body)/\nconst patternBodyEnd = /(<\\/body>)/\nconst patternHtmlEnd = /(<\\/html>)/\nconst patternHeadStart = /(<head.*?>)/\n// regex pattern for matching closing tags\nconst patternClosingTag = /(<\\/[a-zA-Z][\\w:.-]*?>)/g\n\nconst textDecoder = new TextDecoder()\n\ntype ReadablePassthrough = {\n  stream: ReadableStream\n  write: (chunk: string) => void\n  end: (chunk?: string) => void\n  destroy: (error: unknown) => void\n  destroyed: boolean\n}\n\nfunction createPassthrough() {\n  let controller: ReadableStreamDefaultController<any>\n  const encoder = new TextEncoder()\n  const stream = new ReadableStream({\n    start(c) {\n      controller = c\n    },\n  })\n\n  const res: ReadablePassthrough = {\n    stream,\n    write: (chunk) => {\n      controller.enqueue(encoder.encode(chunk))\n    },\n    end: (chunk) => {\n      if (chunk) {\n        controller.enqueue(encoder.encode(chunk))\n      }\n      controller.close()\n      res.destroyed = true\n    },\n    destroy: (error) => {\n      controller.error(error)\n    },\n    destroyed: false,\n  }\n\n  return res\n}\n\nasync function readStream(\n  stream: ReadableStream,\n  opts: {\n    onData?: (chunk: ReadableStreamReadValueResult<any>) => void\n    onEnd?: () => void\n    onError?: (error: unknown) => void\n  },\n) {\n  try {\n    const reader = stream.getReader()\n    let chunk\n    while (!(chunk = await reader.read()).done) {\n      opts.onData?.(chunk)\n    }\n    opts.onEnd?.()\n  } catch (error) {\n    opts.onError?.(error)\n  }\n}\n\nexport function transformStreamWithRouter(\n  router: AnyRouter,\n  appStream: ReadableStream,\n) {\n  const finalPassThrough = createPassthrough()\n\n  let isAppRendering = true as boolean\n  let routerStreamBuffer = ''\n  let pendingClosingTags = ''\n  let bodyStarted = false as boolean\n  let headStarted = false as boolean\n  let leftover = ''\n  let leftoverHtml = ''\n\n  function getBufferedRouterStream() {\n    const html = routerStreamBuffer\n    routerStreamBuffer = ''\n    return html\n  }\n\n  function decodeChunk(chunk: unknown): string {\n    if (chunk instanceof Uint8Array) {\n      return textDecoder.decode(chunk)\n    }\n    return String(chunk)\n  }\n\n  const injectedHtmlDonePromise = createControlledPromise<void>()\n\n  let processingCount = 0\n\n  // Process any already-injected HTML\n  router.serverSsr!.injectedHtml.forEach((promise) => {\n    handleInjectedHtml(promise)\n  })\n\n  // Listen for any new injected HTML\n  const stopListeningToInjectedHtml = router.subscribe(\n    'onInjectedHtml',\n    (e) => {\n      handleInjectedHtml(e.promise)\n    },\n  )\n\n  function handleInjectedHtml(promise: Promise<string>) {\n    processingCount++\n\n    promise\n      .then((html) => {\n        if (!bodyStarted) {\n          routerStreamBuffer += html\n        } else {\n          finalPassThrough.write(html)\n        }\n      })\n      .catch(injectedHtmlDonePromise.reject)\n      .finally(() => {\n        processingCount--\n\n        if (!isAppRendering && processingCount === 0) {\n          stopListeningToInjectedHtml()\n          injectedHtmlDonePromise.resolve()\n        }\n      })\n  }\n\n  injectedHtmlDonePromise\n    .then(() => {\n      const finalHtml =\n        leftoverHtml + getBufferedRouterStream() + pendingClosingTags\n\n      finalPassThrough.end(finalHtml)\n    })\n    .catch((err) => {\n      console.error('Error reading routerStream:', err)\n      finalPassThrough.destroy(err)\n    })\n\n  // Transform the appStream\n  readStream(appStream, {\n    onData: (chunk) => {\n      const text = decodeChunk(chunk.value)\n\n      let chunkString = leftover + text\n      const bodyEndMatch = chunkString.match(patternBodyEnd)\n      const htmlEndMatch = chunkString.match(patternHtmlEnd)\n\n      if (!bodyStarted) {\n        const bodyStartMatch = chunkString.match(patternBodyStart)\n        if (bodyStartMatch) {\n          bodyStarted = true\n        }\n      }\n\n      if (!headStarted) {\n        const headStartMatch = chunkString.match(patternHeadStart)\n        if (headStartMatch) {\n          headStarted = true\n          const index = headStartMatch.index!\n          const headTag = headStartMatch[0]\n          const remaining = chunkString.slice(index + headTag.length)\n          finalPassThrough.write(\n            chunkString.slice(0, index) + headTag + getBufferedRouterStream(),\n          )\n          // make sure to only write `remaining` until the next closing tag\n          chunkString = remaining\n        }\n      }\n\n      if (!bodyStarted) {\n        finalPassThrough.write(chunkString)\n        leftover = ''\n        return\n      }\n\n      // If either the body end or html end is in the chunk,\n      // We need to get all of our data in asap\n      if (\n        bodyEndMatch &&\n        htmlEndMatch &&\n        bodyEndMatch.index! < htmlEndMatch.index!\n      ) {\n        const bodyEndIndex = bodyEndMatch.index!\n        pendingClosingTags = chunkString.slice(bodyEndIndex)\n\n        finalPassThrough.write(\n          chunkString.slice(0, bodyEndIndex) + getBufferedRouterStream(),\n        )\n\n        leftover = ''\n        return\n      }\n\n      let result: RegExpExecArray | null\n      let lastIndex = 0\n      while ((result = patternClosingTag.exec(chunkString)) !== null) {\n        lastIndex = result.index + result[0].length\n      }\n\n      if (lastIndex > 0) {\n        const processed =\n          chunkString.slice(0, lastIndex) +\n          getBufferedRouterStream() +\n          leftoverHtml\n\n        finalPassThrough.write(processed)\n        leftover = chunkString.slice(lastIndex)\n      } else {\n        leftover = chunkString\n        leftoverHtml += getBufferedRouterStream()\n      }\n    },\n    onEnd: () => {\n      // Mark the app as done rendering\n      isAppRendering = false\n      router.serverSsr!.setRenderFinished()\n\n      // If there are no pending promises, resolve the injectedHtmlDonePromise\n      if (processingCount === 0) {\n        injectedHtmlDonePromise.resolve()\n      }\n    },\n    onError: (error) => {\n      console.error('Error reading appStream:', error)\n      finalPassThrough.destroy(error)\n    },\n  })\n\n  return finalPassThrough.stream\n}\n"],"names":[],"mappings":"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"}