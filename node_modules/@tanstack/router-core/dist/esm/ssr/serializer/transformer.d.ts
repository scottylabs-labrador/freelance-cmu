import { Plugin, SerovalNode } from 'seroval';
import { RegisteredConfigType, RegisteredSsr, SSROption } from '../../router.js';
import { LooseReturnType } from '../../utils.js';
import { AnyRoute, ResolveAllSSR } from '../../route.js';
export interface DefaultSerializable {
    number: number;
    string: string;
    boolean: boolean;
    null: null;
    undefined: undefined;
    bigint: bigint;
    Date: Date;
}
export interface SerializableExtensions extends DefaultSerializable {
}
export type Serializable = SerializableExtensions[keyof SerializableExtensions];
export declare function createSerializationAdapter<TInput = unknown, TOutput = unknown>(opts: CreateSerializationAdapterOptions<TInput, TOutput>): SerializationAdapter<TInput, TOutput>;
export interface CreateSerializationAdapterOptions<TInput, TOutput> {
    key: string;
    test: (value: unknown) => value is TInput;
    toSerializable: (value: TInput) => ValidateSerializable<TOutput, Serializable>;
    fromSerializable: (value: TOutput) => TInput;
}
export type ValidateSerializable<T, TSerializable> = T extends ReadonlyArray<unknown> ? ResolveArrayShape<T, TSerializable, 'input'> : T extends TSerializable ? T : T extends (...args: Array<any>) => any ? 'Function is not serializable' : T extends Promise<any> ? ValidateSerializablePromise<T, TSerializable> : T extends ReadableStream<any> ? ValidateReadableStream<T, TSerializable> : T extends Set<any> ? ValidateSerializableSet<T, TSerializable> : T extends Map<any, any> ? ValidateSerializableMap<T, TSerializable> : {
    [K in keyof T]: ValidateSerializable<T[K], TSerializable>;
};
export type ValidateSerializablePromise<T, TSerializable> = T extends Promise<infer TAwaited> ? Promise<ValidateSerializable<TAwaited, TSerializable>> : never;
export type ValidateReadableStream<T, TSerializable> = T extends ReadableStream<infer TStreamed> ? ReadableStream<ValidateSerializable<TStreamed, TSerializable>> : never;
export type ValidateSerializableSet<T, TSerializable> = T extends Set<infer TItem> ? Set<ValidateSerializable<TItem, TSerializable>> : never;
export type ValidateSerializableMap<T, TSerializable> = T extends Map<infer TKey, infer TValue> ? Map<ValidateSerializable<TKey, TSerializable>, ValidateSerializable<TValue, TSerializable>> : never;
export type RegisteredReadableStream = unknown extends SerializerExtensions['ReadableStream'] ? never : SerializerExtensions['ReadableStream'];
export interface DefaultSerializerExtensions {
    ReadableStream: unknown;
}
export interface SerializerExtensions extends DefaultSerializerExtensions {
}
export interface SerializationAdapter<TInput, TOutput> {
    '~types': SerializationAdapterTypes<TInput, TOutput>;
    key: string;
    test: (value: unknown) => value is TInput;
    toSerializable: (value: TInput) => TOutput;
    fromSerializable: (value: TOutput) => TInput;
    makePlugin: (options: {
        didRun: boolean;
    }) => Plugin<TInput, SerovalNode>;
}
export interface SerializationAdapterTypes<TInput, TOutput> {
    input: TInput;
    output: TOutput;
}
export type AnySerializationAdapter = SerializationAdapter<any, any>;
export declare function makeSsrSerovalPlugin<TInput, TOutput>(serializationAdapter: SerializationAdapter<TInput, TOutput>, options: {
    didRun: boolean;
}): Plugin<TInput, SerovalNode>;
export declare function makeSerovalPlugin<TInput, TOutput>(serializationAdapter: SerializationAdapter<TInput, TOutput>): Plugin<TInput, SerovalNode>;
export type ValidateSerializableInput<TRegister, T> = ValidateSerializable<T, RegisteredSerializableInput<TRegister>>;
export type RegisteredSerializableInput<TRegister> = (unknown extends RegisteredSerializationAdapters<TRegister> ? never : RegisteredSerializationAdapters<TRegister> extends ReadonlyArray<AnySerializationAdapter> ? RegisteredSerializationAdapters<TRegister>[number]['~types']['input'] : never) | Serializable;
export type RegisteredSerializationAdapters<TRegister> = RegisteredConfigType<TRegister, 'serializationAdapters'>;
export type ValidateSerializableInputResult<TRegister, T> = ValidateSerializableResult<T, RegisteredSerializableInput<TRegister>>;
export type ValidateSerializableResult<T, TSerializable> = T extends ReadonlyArray<unknown> ? ResolveArrayShape<T, TSerializable, 'result'> : T extends TSerializable ? T : unknown extends SerializerExtensions['ReadableStream'] ? {
    [K in keyof T]: ValidateSerializableResult<T[K], TSerializable>;
} : T extends SerializerExtensions['ReadableStream'] ? ReadableStream : {
    [K in keyof T]: ValidateSerializableResult<T[K], TSerializable>;
};
export type RegisteredSSROption<TRegister> = unknown extends RegisteredConfigType<TRegister, 'defaultSsr'> ? SSROption : RegisteredConfigType<TRegister, 'defaultSsr'>;
export type ValidateSerializableLifecycleResult<TRegister, TParentRoute extends AnyRoute, TSSR, TFn> = false extends RegisteredSsr<TRegister> ? any : ValidateSerializableLifecycleResultSSR<TRegister, TParentRoute, TSSR, TFn> extends infer TInput ? TInput : never;
export type ValidateSerializableLifecycleResultSSR<TRegister, TParentRoute extends AnyRoute, TSSR, TFn> = ResolveAllSSR<TParentRoute, TSSR> extends false ? any : RegisteredSSROption<TRegister> extends false ? any : ValidateSerializableInput<TRegister, LooseReturnType<TFn>>;
type ResolveArrayShape<T extends ReadonlyArray<unknown>, TSerializable, TMode extends 'input' | 'result'> = number extends T['length'] ? T extends Array<infer U> ? Array<ArrayModeResult<TMode, U, TSerializable>> : ReadonlyArray<ArrayModeResult<TMode, T[number], TSerializable>> : ResolveTupleShape<T, TSerializable, TMode>;
type ResolveTupleShape<T extends ReadonlyArray<unknown>, TSerializable, TMode extends 'input' | 'result'> = T extends readonly [infer THead, ...infer TTail] ? readonly [
    ArrayModeResult<TMode, THead, TSerializable>,
    ...ResolveTupleShape<Readonly<TTail>, TSerializable, TMode>
] : T;
type ArrayModeResult<TMode extends 'input' | 'result', TValue, TSerializable> = TMode extends 'input' ? ValidateSerializable<TValue, TSerializable> : ValidateSerializableResult<TValue, TSerializable>;
export {};
