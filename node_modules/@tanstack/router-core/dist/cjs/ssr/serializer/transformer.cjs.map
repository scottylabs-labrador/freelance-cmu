{"version":3,"file":"transformer.cjs","sources":["../../../../src/ssr/serializer/transformer.ts"],"sourcesContent":["import { createPlugin } from 'seroval'\nimport { GLOBAL_TSR } from '../constants'\nimport type { Plugin, SerovalNode } from 'seroval'\nimport type {\n  RegisteredConfigType,\n  RegisteredSsr,\n  SSROption,\n} from '../../router'\nimport type { LooseReturnType } from '../../utils'\nimport type { AnyRoute, ResolveAllSSR } from '../../route'\n\nexport interface DefaultSerializable {\n  number: number\n  string: string\n  boolean: boolean\n  null: null\n  undefined: undefined\n  bigint: bigint\n  Date: Date\n}\n\nexport interface SerializableExtensions extends DefaultSerializable {}\n\nexport type Serializable = SerializableExtensions[keyof SerializableExtensions]\n\nexport function createSerializationAdapter<\n  TInput = unknown,\n  TOutput = unknown /* we need to check that this type is actually serializable taking into account all seroval native types and any custom plugin WE=router/start add!!! */,\n>(\n  opts: CreateSerializationAdapterOptions<TInput, TOutput>,\n): SerializationAdapter<TInput, TOutput> {\n  return opts as unknown as SerializationAdapter<TInput, TOutput>\n}\n\nexport interface CreateSerializationAdapterOptions<TInput, TOutput> {\n  key: string\n  test: (value: unknown) => value is TInput\n  toSerializable: (value: TInput) => ValidateSerializable<TOutput, Serializable>\n  fromSerializable: (value: TOutput) => TInput\n}\n\nexport type ValidateSerializable<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'input'>\n    : T extends TSerializable\n      ? T\n      : T extends (...args: Array<any>) => any\n        ? 'Function is not serializable'\n        : T extends Promise<any>\n          ? ValidateSerializablePromise<T, TSerializable>\n          : T extends ReadableStream<any>\n            ? ValidateReadableStream<T, TSerializable>\n            : T extends Set<any>\n              ? ValidateSerializableSet<T, TSerializable>\n              : T extends Map<any, any>\n                ? ValidateSerializableMap<T, TSerializable>\n                : { [K in keyof T]: ValidateSerializable<T[K], TSerializable> }\n\nexport type ValidateSerializablePromise<T, TSerializable> =\n  T extends Promise<infer TAwaited>\n    ? Promise<ValidateSerializable<TAwaited, TSerializable>>\n    : never\n\nexport type ValidateReadableStream<T, TSerializable> =\n  T extends ReadableStream<infer TStreamed>\n    ? ReadableStream<ValidateSerializable<TStreamed, TSerializable>>\n    : never\n\nexport type ValidateSerializableSet<T, TSerializable> =\n  T extends Set<infer TItem>\n    ? Set<ValidateSerializable<TItem, TSerializable>>\n    : never\n\nexport type ValidateSerializableMap<T, TSerializable> =\n  T extends Map<infer TKey, infer TValue>\n    ? Map<\n        ValidateSerializable<TKey, TSerializable>,\n        ValidateSerializable<TValue, TSerializable>\n      >\n    : never\n\nexport type RegisteredReadableStream =\n  unknown extends SerializerExtensions['ReadableStream']\n    ? never\n    : SerializerExtensions['ReadableStream']\n\nexport interface DefaultSerializerExtensions {\n  ReadableStream: unknown\n}\n\nexport interface SerializerExtensions extends DefaultSerializerExtensions {}\n\nexport interface SerializationAdapter<TInput, TOutput> {\n  '~types': SerializationAdapterTypes<TInput, TOutput>\n  key: string\n  test: (value: unknown) => value is TInput\n  toSerializable: (value: TInput) => TOutput\n  fromSerializable: (value: TOutput) => TInput\n  makePlugin: (options: { didRun: boolean }) => Plugin<TInput, SerovalNode>\n}\n\nexport interface SerializationAdapterTypes<TInput, TOutput> {\n  input: TInput\n  output: TOutput\n}\n\nexport type AnySerializationAdapter = SerializationAdapter<any, any>\n\nexport function makeSsrSerovalPlugin<TInput, TOutput>(\n  serializationAdapter: SerializationAdapter<TInput, TOutput>,\n  options: { didRun: boolean },\n) {\n  return createPlugin<TInput, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    serialize(node, ctx) {\n      options.didRun = true\n      return (\n        GLOBAL_TSR +\n        '.t.get(\"' +\n        serializationAdapter.key +\n        '\")(' +\n        ctx.serialize(node) +\n        ')'\n      )\n    },\n    // we never deserialize on the server during SSR\n    deserialize: undefined as never,\n  })\n}\n\nexport function makeSerovalPlugin<TInput, TOutput>(\n  serializationAdapter: SerializationAdapter<TInput, TOutput>,\n) {\n  return createPlugin<TInput, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      sync(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      async async(value, ctx) {\n        return await ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    // we don't generate JS code outside of SSR (for now)\n    serialize: undefined as never,\n    deserialize(node, ctx) {\n      return serializationAdapter.fromSerializable(\n        ctx.deserialize(node) as TOutput,\n      )\n    },\n  })\n}\n\nexport type ValidateSerializableInput<TRegister, T> = ValidateSerializable<\n  T,\n  RegisteredSerializableInput<TRegister>\n>\n\nexport type RegisteredSerializableInput<TRegister> =\n  | (unknown extends RegisteredSerializationAdapters<TRegister>\n      ? never\n      : RegisteredSerializationAdapters<TRegister> extends ReadonlyArray<AnySerializationAdapter>\n        ? RegisteredSerializationAdapters<TRegister>[number]['~types']['input']\n        : never)\n  | Serializable\n\nexport type RegisteredSerializationAdapters<TRegister> = RegisteredConfigType<\n  TRegister,\n  'serializationAdapters'\n>\n\nexport type ValidateSerializableInputResult<TRegister, T> =\n  ValidateSerializableResult<T, RegisteredSerializableInput<TRegister>>\n\nexport type ValidateSerializableResult<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'result'>\n    : T extends TSerializable\n      ? T\n      : unknown extends SerializerExtensions['ReadableStream']\n        ? { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n        : T extends SerializerExtensions['ReadableStream']\n          ? ReadableStream\n          : { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n\nexport type RegisteredSSROption<TRegister> =\n  unknown extends RegisteredConfigType<TRegister, 'defaultSsr'>\n    ? SSROption\n    : RegisteredConfigType<TRegister, 'defaultSsr'>\n\nexport type ValidateSerializableLifecycleResult<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  false extends RegisteredSsr<TRegister>\n    ? any\n    : ValidateSerializableLifecycleResultSSR<\n          TRegister,\n          TParentRoute,\n          TSSR,\n          TFn\n        > extends infer TInput\n      ? TInput\n      : never\n\nexport type ValidateSerializableLifecycleResultSSR<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  ResolveAllSSR<TParentRoute, TSSR> extends false\n    ? any\n    : RegisteredSSROption<TRegister> extends false\n      ? any\n      : ValidateSerializableInput<TRegister, LooseReturnType<TFn>>\n\ntype ResolveArrayShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = number extends T['length']\n  ? T extends Array<infer U>\n    ? Array<ArrayModeResult<TMode, U, TSerializable>>\n    : ReadonlyArray<ArrayModeResult<TMode, T[number], TSerializable>>\n  : ResolveTupleShape<T, TSerializable, TMode>\n\ntype ResolveTupleShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = T extends readonly [infer THead, ...infer TTail]\n  ? readonly [\n      ArrayModeResult<TMode, THead, TSerializable>,\n      ...ResolveTupleShape<Readonly<TTail>, TSerializable, TMode>,\n    ]\n  : T\n\ntype ArrayModeResult<\n  TMode extends 'input' | 'result',\n  TValue,\n  TSerializable,\n> = TMode extends 'input'\n  ? ValidateSerializable<TValue, TSerializable>\n  : ValidateSerializableResult<TValue, TSerializable>\n"],"names":["createPlugin","GLOBAL_TSR"],"mappings":";;;;AAyBO,SAAS,2BAId,MACuC;AACvC,SAAO;AACT;AA4EO,SAAS,qBACd,sBACA,SACA;AACA,SAAOA,qBAAkC;AAAA,IACvC,KAAK,YAAY,qBAAqB;AAAA,IACtC,MAAM,qBAAqB;AAAA,IAC3B,OAAO;AAAA,MACL,OAAO,OAAO,KAAK;AACjB,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,IAAA;AAAA,IAEF,UAAU,MAAM,KAAK;AACnB,cAAQ,SAAS;AACjB,aACEC,UAAAA,aACA,aACA,qBAAqB,MACrB,QACA,IAAI,UAAU,IAAI,IAClB;AAAA,IAEJ;AAAA;AAAA,IAEA,aAAa;AAAA,EAAA,CACd;AACH;AAEO,SAAS,kBACd,sBACA;AACA,SAAOD,qBAAkC;AAAA,IACvC,KAAK,YAAY,qBAAqB;AAAA,IACtC,MAAM,qBAAqB;AAAA,IAC3B,OAAO;AAAA,MACL,KAAK,OAAO,KAAK;AACf,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,MACA,MAAM,MAAM,OAAO,KAAK;AACtB,eAAO,MAAM,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MACnE;AAAA,MACA,OAAO,OAAO,KAAK;AACjB,eAAO,IAAI,MAAM,qBAAqB,eAAe,KAAK,CAAC;AAAA,MAC7D;AAAA,IAAA;AAAA;AAAA,IAGF,WAAW;AAAA,IACX,YAAY,MAAM,KAAK;AACrB,aAAO,qBAAqB;AAAA,QAC1B,IAAI,YAAY,IAAI;AAAA,MAAA;AAAA,IAExB;AAAA,EAAA,CACD;AACH;;;;"}