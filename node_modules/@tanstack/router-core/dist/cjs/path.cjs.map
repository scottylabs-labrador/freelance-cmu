{"version":3,"file":"path.cjs","sources":["../../src/path.ts"],"sourcesContent":["import { rootRouteId } from './root'\nimport { last } from './utils'\nimport type { LRUCache } from './lru-cache'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport interface Segment {\n  readonly type:\n    | typeof SEGMENT_TYPE_PATHNAME\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  readonly value: string\n  readonly prefixSegment?: string\n  readonly suffixSegment?: string\n  // Indicates if there is a static segment after this required/optional param\n  readonly hasStaticAfter?: boolean\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  parseCache?: ParsePathnameCache\n}\n\nfunction segmentToString(segment: Segment): string {\n  const { type, value } = segment\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value\n  }\n\n  const { prefixSegment, suffixSegment } = segment\n\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`\n    }\n  }\n\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`\n    }\n    return `{-$${param}}`\n  }\n\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`\n    }\n  }\n\n  // This case should never happen, should we throw instead?\n  return value\n}\n\nexport function resolvePath({\n  base,\n  to,\n  trailingSlash = 'never',\n  parseCache,\n}: ResolvePathOptions) {\n  let baseSegments = parseBasePathSegments(base, parseCache).slice()\n  const toSegments = parseRoutePathSegments(to, parseCache)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index]!\n    const value = toSegment.value\n    if (value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (value === '..') {\n      baseSegments.pop()\n    } else if (value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)!.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map(segmentToString)\n  // const joined = joinPaths([basepath, ...segmentValues])\n  const joined = joinPaths(segmentValues)\n  return joined\n}\n\nexport type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>\n\nexport const parseBasePathSegments = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => parsePathname(pathname, cache, true)\n\nexport const parseRoutePathSegments = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => parsePathname(pathname, cache, false)\n\nexport const parsePathname = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n  basePathValues?: boolean,\n): ReadonlyArray<Segment> => {\n  if (!pathname) return []\n  const cached = cache?.get(pathname)\n  if (cached) return cached\n  const parsed = baseParsePathname(pathname, basePathValues)\n  cache?.set(pathname, parsed)\n  return parsed\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{-$paramName}suffix\n\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Optional param: `/foo/{-$bar}`\n * Optional param with Prefix and Suffix: `/foo/prefix{-$bar}suffix`\n\n * Future:\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nfunction baseParsePathname(\n  pathname: string,\n  basePathValues?: boolean,\n): ReadonlyArray<Segment> {\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // strip tailing underscore for non-nested paths\n      const partToMatch =\n        !basePathValues && part !== rootRouteId && part.slice(-1) === '_'\n          ? part.slice(0, -1)\n          : part\n\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = partToMatch.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for optional parameter format: prefix{-$paramName}suffix\n      const optionalParamBracesMatch = partToMatch.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE,\n      )\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1]\n        const paramName = optionalParamBracesMatch[2]!\n        const suffix = optionalParamBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName, // Now just $paramName (no prefix)\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = partToMatch.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(partToMatch)) {\n        const paramName = partToMatch.substring(1)\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(partToMatch)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: partToMatch.includes('%25')\n          ? partToMatch\n              .split('%25')\n              .map((segment) => decodeURI(segment))\n              .join('%25')\n          : decodeURI(partToMatch),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n  parseCache?: ParsePathnameCache\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parseRoutePathSegments(path, parseCache)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (key === '*' || key === '_splat') {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value\n      }\n\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat\n\n        // TODO: Deprecate *\n        usedParams['*'] = params._splat\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if _splat parameter is missing\n        if (!('_splat' in params)) {\n          isMissingParams = true\n          // For missing splat parameters, just return the prefix and suffix without the wildcard\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`\n          }\n          // If there is a prefix or suffix, return them joined, otherwise omit the segment\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          return undefined\n        }\n\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1)\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if optional parameter is missing or undefined\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`\n          }\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          // If no prefix/suffix, omit the entire segment\n          return undefined\n        }\n\n        usedParams[key] = params[key]\n\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? ''}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\nexport function matchPathname(\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n  parseCache?: ParsePathnameCache,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(currentPathname, matchLocation, parseCache)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  from: string,\n  {\n    to,\n    fuzzy,\n    caseSensitive,\n  }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n  parseCache?: ParsePathnameCache,\n): Record<string, string> | undefined {\n  const stringTo = to as string\n\n  // Parse the from and to\n  const baseSegments = parseBasePathSegments(\n    from.startsWith('/') ? from : `/${from}`,\n    parseCache,\n  )\n  const routeSegments = parseRoutePathSegments(\n    stringTo.startsWith('/') ? stringTo : `/${stringTo}`,\n    parseCache,\n  )\n\n  const params: Record<string, string> = {}\n\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive,\n  )\n\n  return result ? params : undefined\n}\n\nfunction isMatch(\n  baseSegments: ReadonlyArray<Segment>,\n  routeSegments: ReadonlyArray<Segment>,\n  params: Record<string, string>,\n  fuzzy?: boolean,\n  caseSensitive?: boolean,\n): boolean {\n  let baseIndex = 0\n  let routeIndex = 0\n\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex]\n    const routeSegment = routeSegments[routeIndex]\n\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        // Capture all remaining segments for a wildcard\n        const remainingBaseSegments = baseSegments.slice(baseIndex)\n\n        let _splat: string\n\n        // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false\n\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if ('prefixSegment' in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false\n            }\n          }\n          if ('suffixSegment' in routeSegment) {\n            if (\n              !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n            ) {\n              return false\n            }\n          }\n\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n\n          // Remove the prefix and suffix from the rejoined splat\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length)\n          }\n\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length,\n            )\n          }\n\n          _splat = rejoinedSplat\n        } else {\n          // If no prefix/suffix, just rejoin the remaining segments\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n        }\n\n        // TODO: Deprecate *\n        params['*'] = _splat\n        params['_splat'] = _splat\n        return true\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === '/' && !baseSegment?.value) {\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          } else if (\n            routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()\n          ) {\n            return false\n          }\n          baseIndex++\n          routeIndex++\n          continue\n        } else {\n          return false\n        }\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false\n        }\n\n        if (baseSegment.value === '/') {\n          return false\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false\n          }\n\n          let paramValue = baseValue\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length)\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length)\n          }\n\n          _paramValue = decodeURIComponent(paramValue)\n          matched = true\n        } else {\n          // If no prefix/suffix, just decode the base segment value\n          _paramValue = decodeURIComponent(baseSegment.value)\n          matched = true\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        // Optional parameters can be missing - don't fail the match\n        if (!baseSegment) {\n          // No base segment for optional param - skip this route segment\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment.value === '/') {\n          // Skip slash segments for optional params\n          routeIndex++\n          continue\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this optional param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (\n            (!prefix || baseValue.startsWith(prefix)) &&\n            (!suffix || baseValue.endsWith(suffix))\n          ) {\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n            matched = true\n          }\n        } else {\n          // For optional params without prefix/suffix, we need to check if the current\n          // base segment should match this optional param or a later route segment\n\n          // Look ahead to see if there's a later route segment that matches the current base segment\n          let shouldMatchOptional = true\n          for (\n            let lookAhead = routeIndex + 1;\n            lookAhead < routeSegments.length;\n            lookAhead++\n          ) {\n            const futureRouteSegment = routeSegments[lookAhead]\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n              futureRouteSegment.value === baseSegment.value\n            ) {\n              // The current base segment matches a future pathname segment,\n              // so we should skip this optional parameter\n              shouldMatchOptional = false\n              break\n            }\n\n            // If we encounter a required param or wildcard, stop looking ahead\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n              futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n            ) {\n              if (baseSegments.length < routeSegments.length) {\n                shouldMatchOptional = false\n              }\n              break\n            }\n          }\n\n          if (shouldMatchOptional) {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n            matched = true\n          }\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n    }\n\n    // If we have base segments left but no route segments, it's a fuzzy match\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params['**'] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value),\n      )\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== '/'\n    }\n\n    // If we have route segments left but no base segments, check if remaining are optional\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      // Check if all remaining route segments are optional\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false\n        }\n      }\n      // All remaining are optional, so we can finish\n      break\n    }\n\n    break\n  }\n\n  return true\n}\n"],"names":["last","rootRouteId"],"mappings":";;;;AAMO,MAAM,wBAAwB;AAC9B,MAAM,qBAAqB;AAC3B,MAAM,wBAAwB;AAC9B,MAAM,8BAA8B;AAepC,SAAS,UAAU,OAAkC;AAC1D,SAAO;AAAA,IACL,MACG,OAAO,CAAC,QAAQ;AACf,aAAO,QAAQ;AAAA,IACjB,CAAC,EACA,KAAK,GAAG;AAAA,EAAA;AAEf;AAEO,SAAS,UAAU,MAAc;AAEtC,SAAO,KAAK,QAAQ,WAAW,GAAG;AACpC;AAEO,SAAS,aAAa,MAAc;AACzC,SAAO,SAAS,MAAM,OAAO,KAAK,QAAQ,WAAW,EAAE;AACzD;AAEO,SAAS,cAAc,MAAc;AAC1C,SAAO,SAAS,MAAM,OAAO,KAAK,QAAQ,WAAW,EAAE;AACzD;AAEO,SAAS,SAAS,MAAc;AACrC,SAAO,cAAc,aAAa,IAAI,CAAC;AACzC;AAEO,SAAS,oBAAoB,OAAe,UAA0B;AAC3E,MAAI,OAAO,SAAS,GAAG,KAAK,UAAU,OAAO,UAAU,GAAG,QAAQ,KAAK;AACrE,WAAO,MAAM,MAAM,GAAG,EAAE;AAAA,EAC1B;AACA,SAAO;AACT;AAMO,SAAS,cACd,WACA,WACA,UACS;AACT,SACE,oBAAoB,WAAW,QAAQ,MACvC,oBAAoB,WAAW,QAAQ;AAE3C;AAmCA,SAAS,gBAAgB,SAA0B;AACjD,QAAM,EAAE,MAAM,MAAA,IAAU;AACxB,MAAI,SAAS,uBAAuB;AAClC,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,eAAe,cAAA,IAAkB;AAEzC,MAAI,SAAS,oBAAoB;AAC/B,UAAM,QAAQ,MAAM,UAAU,CAAC;AAC/B,QAAI,iBAAiB,eAAe;AAClC,aAAO,GAAG,aAAa,KAAK,KAAK,IAAI,aAAa;AAAA,IACpD,WAAW,eAAe;AACxB,aAAO,GAAG,aAAa,KAAK,KAAK;AAAA,IACnC,WAAW,eAAe;AACxB,aAAO,KAAK,KAAK,IAAI,aAAa;AAAA,IACpC;AAAA,EACF;AAEA,MAAI,SAAS,6BAA6B;AACxC,UAAM,QAAQ,MAAM,UAAU,CAAC;AAC/B,QAAI,iBAAiB,eAAe;AAClC,aAAO,GAAG,aAAa,MAAM,KAAK,IAAI,aAAa;AAAA,IACrD,WAAW,eAAe;AACxB,aAAO,GAAG,aAAa,MAAM,KAAK;AAAA,IACpC,WAAW,eAAe;AACxB,aAAO,MAAM,KAAK,IAAI,aAAa;AAAA,IACrC;AACA,WAAO,MAAM,KAAK;AAAA,EACpB;AAEA,MAAI,SAAS,uBAAuB;AAClC,QAAI,iBAAiB,eAAe;AAClC,aAAO,GAAG,aAAa,MAAM,aAAa;AAAA,IAC5C,WAAW,eAAe;AACxB,aAAO,GAAG,aAAa;AAAA,IACzB,WAAW,eAAe;AACxB,aAAO,MAAM,aAAa;AAAA,IAC5B;AAAA,EACF;AAGA,SAAO;AACT;AAEO,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AAAA,EACA,gBAAgB;AAAA,EAChB;AACF,GAAuB;AACrB,MAAI,eAAe,sBAAsB,MAAM,UAAU,EAAE,MAAA;AAC3D,QAAM,aAAa,uBAAuB,IAAI,UAAU;AAExD,MAAI,aAAa,SAAS,KAAKA,MAAAA,KAAK,YAAY,GAAG,UAAU,KAAK;AAChE,iBAAa,IAAA;AAAA,EACf;AAEA,WAAS,QAAQ,GAAG,SAAS,WAAW,QAAQ,QAAQ,QAAQ,SAAS;AACvE,UAAM,YAAY,WAAW,KAAK;AAClC,UAAM,QAAQ,UAAU;AACxB,QAAI,UAAU,KAAK;AACjB,UAAI,CAAC,OAAO;AAEV,uBAAe,CAAC,SAAS;AAAA,MAC3B,WAAW,UAAU,SAAS,GAAG;AAE/B,qBAAa,KAAK,SAAS;AAAA,MAC7B,MAAO;AAAA,IAGT,WAAW,UAAU,MAAM;AACzB,mBAAa,IAAA;AAAA,IACf,WAAW,UAAU,IAAK;AAAA,SAEnB;AACL,mBAAa,KAAK,SAAS;AAAA,IAC7B;AAAA,EACF;AAEA,MAAI,aAAa,SAAS,GAAG;AAC3B,QAAIA,WAAK,YAAY,EAAG,UAAU,KAAK;AACrC,UAAI,kBAAkB,SAAS;AAC7B,qBAAa,IAAA;AAAA,MACf;AAAA,IACF,WAAW,kBAAkB,UAAU;AACrC,mBAAa,KAAK,EAAE,MAAM,uBAAuB,OAAO,KAAK;AAAA,IAC/D;AAAA,EACF;AAEA,QAAM,gBAAgB,aAAa,IAAI,eAAe;AAEtD,QAAM,SAAS,UAAU,aAAa;AACtC,SAAO;AACT;AAIO,MAAM,wBAAwB,CACnC,UACA,UAC2B,cAAc,UAAU,OAAO,IAAI;AAEzD,MAAM,yBAAyB,CACpC,UACA,UAC2B,cAAc,UAAU,OAAO,KAAK;AAE1D,MAAM,gBAAgB,CAC3B,UACA,OACA,mBAC2B;AAC3B,MAAI,CAAC,SAAU,QAAO,CAAA;AACtB,QAAM,SAAS,OAAO,IAAI,QAAQ;AAClC,MAAI,OAAQ,QAAO;AACnB,QAAM,SAAS,kBAAkB,UAAU,cAAc;AACzD,SAAO,IAAI,UAAU,MAAM;AAC3B,SAAO;AACT;AAEA,MAAM,WAAW;AACjB,MAAM,0BAA0B;AAChC,MAAM,mCACJ;AAEF,MAAM,cAAc;AACpB,MAAM,6BAA6B;AAmBnC,SAAS,kBACP,UACA,gBACwB;AACxB,aAAW,UAAU,QAAQ;AAE7B,QAAM,WAA2B,CAAA;AAEjC,MAAI,SAAS,MAAM,GAAG,CAAC,MAAM,KAAK;AAChC,eAAW,SAAS,UAAU,CAAC;AAC/B,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AAEA,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAGA,QAAM,QAAQ,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO;AAEhD,WAAS;AAAA,IACP,GAAG,MAAM,IAAI,CAAC,SAAkB;AAE9B,YAAM,cACJ,CAAC,kBAAkB,SAASC,KAAAA,eAAe,KAAK,MAAM,EAAE,MAAM,MAC1D,KAAK,MAAM,GAAG,EAAE,IAChB;AAGN,YAAM,sBAAsB,YAAY,MAAM,0BAA0B;AACxE,UAAI,qBAAqB;AACvB,cAAM,SAAS,oBAAoB,CAAC;AACpC,cAAM,SAAS,oBAAoB,CAAC;AACpC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,UACP,eAAe,UAAU;AAAA,UACzB,eAAe,UAAU;AAAA,QAAA;AAAA,MAE7B;AAGA,YAAM,2BAA2B,YAAY;AAAA,QAC3C;AAAA,MAAA;AAEF,UAAI,0BAA0B;AAC5B,cAAM,SAAS,yBAAyB,CAAC;AACzC,cAAM,YAAY,yBAAyB,CAAC;AAC5C,cAAM,SAAS,yBAAyB,CAAC;AACzC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA;AAAA,UACP,eAAe,UAAU;AAAA,UACzB,eAAe,UAAU;AAAA,QAAA;AAAA,MAE7B;AAGA,YAAM,mBAAmB,YAAY,MAAM,uBAAuB;AAClE,UAAI,kBAAkB;AACpB,cAAM,SAAS,iBAAiB,CAAC;AACjC,cAAM,YAAY,iBAAiB,CAAC;AACpC,cAAM,SAAS,iBAAiB,CAAC;AACjC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO,KAAK;AAAA,UACZ,eAAe,UAAU;AAAA,UACzB,eAAe,UAAU;AAAA,QAAA;AAAA,MAE7B;AAGA,UAAI,SAAS,KAAK,WAAW,GAAG;AAC9B,cAAM,YAAY,YAAY,UAAU,CAAC;AACzC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO,MAAM;AAAA,UACb,eAAe;AAAA,UACf,eAAe;AAAA,QAAA;AAAA,MAEnB;AAGA,UAAI,YAAY,KAAK,WAAW,GAAG;AACjC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,UACP,eAAe;AAAA,UACf,eAAe;AAAA,QAAA;AAAA,MAEnB;AAGA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,YAAY,SAAS,KAAK,IAC7B,YACG,MAAM,KAAK,EACX,IAAI,CAAC,YAAY,UAAU,OAAO,CAAC,EACnC,KAAK,KAAK,IACb,UAAU,WAAW;AAAA,MAAA;AAAA,IAE7B,CAAC;AAAA,EAAA;AAGH,MAAI,SAAS,MAAM,EAAE,MAAM,KAAK;AAC9B,eAAW,SAAS,UAAU,CAAC;AAC/B,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AAEA,SAAO;AACT;AAiBO,SAAS,gBAAgB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAkD;AAChD,QAAM,2BAA2B,uBAAuB,MAAM,UAAU;AAExE,WAAS,YAAY,KAAkB;AACrC,UAAM,QAAQ,OAAO,GAAG;AACxB,UAAM,gBAAgB,OAAO,UAAU;AAEvC,QAAI,QAAQ,OAAO,QAAQ,UAAU;AAEnC,aAAO,gBAAgB,UAAU,KAAK,IAAI;AAAA,IAC5C,OAAO;AACL,aAAO,gBAAgB,gBAAgB,OAAO,aAAa,IAAI;AAAA,IACjE;AAAA,EACF;AAIA,MAAI,kBAAkB;AAEtB,QAAM,aAAsC,CAAA;AAC5C,QAAM,mBAAmB;AAAA,IACvB,yBAAyB,IAAI,CAAC,YAAY;AACxC,UAAI,QAAQ,SAAS,uBAAuB;AAC1C,eAAO,QAAQ;AAAA,MACjB;AAEA,UAAI,QAAQ,SAAS,uBAAuB;AAC1C,mBAAW,SAAS,OAAO;AAG3B,mBAAW,GAAG,IAAI,OAAO;AAEzB,cAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,cAAM,gBAAgB,QAAQ,iBAAiB;AAG/C,YAAI,EAAE,YAAY,SAAS;AACzB,4BAAkB;AAElB,cAAI,gBAAgB;AAClB,mBAAO,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,aAAa;AAAA,UACzD;AAEA,cAAI,iBAAiB,eAAe;AAClC,mBAAO,GAAG,aAAa,GAAG,aAAa;AAAA,UACzC;AACA,iBAAO;AAAA,QACT;AAEA,cAAM,QAAQ,YAAY,QAAQ;AAClC,YAAI,gBAAgB;AAClB,iBAAO,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,SAAS,EAAE,GAAG,aAAa;AAAA,QACvE;AACA,eAAO,GAAG,aAAa,GAAG,KAAK,GAAG,aAAa;AAAA,MACjD;AAEA,UAAI,QAAQ,SAAS,oBAAoB;AACvC,cAAM,MAAM,QAAQ,MAAM,UAAU,CAAC;AACrC,YAAI,CAAC,mBAAmB,EAAE,OAAO,SAAS;AACxC,4BAAkB;AAAA,QACpB;AACA,mBAAW,GAAG,IAAI,OAAO,GAAG;AAE5B,cAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,cAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,YAAI,aAAa;AACf,gBAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,iBAAO,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,SAAS,EAAE,GAAG,aAAa;AAAA,QACvE;AACA,eAAO,GAAG,aAAa,GAAG,YAAY,GAAG,KAAK,WAAW,GAAG,aAAa;AAAA,MAC3E;AAEA,UAAI,QAAQ,SAAS,6BAA6B;AAChD,cAAM,MAAM,QAAQ,MAAM,UAAU,CAAC;AAErC,cAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,cAAM,gBAAgB,QAAQ,iBAAiB;AAG/C,YAAI,EAAE,OAAO,WAAW,OAAO,GAAG,KAAK,MAAM;AAC3C,cAAI,gBAAgB;AAClB,mBAAO,GAAG,aAAa,GAAG,GAAG,GAAG,aAAa;AAAA,UAC/C;AAEA,cAAI,iBAAiB,eAAe;AAClC,mBAAO,GAAG,aAAa,GAAG,aAAa;AAAA,UACzC;AAEA,iBAAO;AAAA,QACT;AAEA,mBAAW,GAAG,IAAI,OAAO,GAAG;AAE5B,YAAI,aAAa;AACf,gBAAM,QAAQ,YAAY,QAAQ,KAAK;AACvC,iBAAO,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,SAAS,EAAE,GAAG,aAAa;AAAA,QACvE;AACA,YAAI,gBAAgB;AAClB,iBAAO,GAAG,aAAa,GAAG,GAAG,GAAG,YAAY,GAAG,KAAK,EAAE,GAAG,aAAa;AAAA,QACxE;AACA,eAAO,GAAG,aAAa,GAAG,YAAY,GAAG,KAAK,EAAE,GAAG,aAAa;AAAA,MAClE;AAEA,aAAO,QAAQ;AAAA,IACjB,CAAC;AAAA,EAAA;AAEH,SAAO,EAAE,YAAY,kBAAkB,gBAAA;AACzC;AAEA,SAAS,gBAAgB,OAAe,eAAqC;AAC3E,MAAI,UAAU,mBAAmB,KAAK;AACtC,MAAI,eAAe;AACjB,eAAW,CAAC,aAAa,IAAI,KAAK,eAAe;AAC/C,gBAAU,QAAQ,WAAW,aAAa,IAAI;AAAA,IAChD;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,cACd,iBACA,eACA,YAC2B;AAC3B,QAAM,aAAa,YAAY,iBAAiB,eAAe,UAAU;AAGzE,MAAI,cAAc,MAAM,CAAC,YAAY;AACnC;AAAA,EACF;AAEA,SAAO,cAAc,CAAA;AACvB;AAEO,SAAS,YACd,MACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GACA,YACoC;AACpC,QAAM,WAAW;AAGjB,QAAM,eAAe;AAAA,IACnB,KAAK,WAAW,GAAG,IAAI,OAAO,IAAI,IAAI;AAAA,IACtC;AAAA,EAAA;AAEF,QAAM,gBAAgB;AAAA,IACpB,SAAS,WAAW,GAAG,IAAI,WAAW,IAAI,QAAQ;AAAA,IAClD;AAAA,EAAA;AAGF,QAAM,SAAiC,CAAA;AAEvC,QAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAGF,SAAO,SAAS,SAAS;AAC3B;AAEA,SAAS,QACP,cACA,eACA,QACA,OACA,eACS;AACT,MAAI,YAAY;AAChB,MAAI,aAAa;AAEjB,SAAO,YAAY,aAAa,UAAU,aAAa,cAAc,QAAQ;AAC3E,UAAM,cAAc,aAAa,SAAS;AAC1C,UAAM,eAAe,cAAc,UAAU;AAE7C,QAAI,cAAc;AAChB,UAAI,aAAa,SAAS,uBAAuB;AAE/C,cAAM,wBAAwB,aAAa,MAAM,SAAS;AAE1D,YAAI;AAGJ,YAAI,aAAa,iBAAiB,aAAa,eAAe;AAC5D,cAAI,CAAC,YAAa,QAAO;AAEzB,gBAAM,SAAS,aAAa,iBAAiB;AAC7C,gBAAM,SAAS,aAAa,iBAAiB;AAG7C,gBAAM,YAAY,YAAY;AAC9B,cAAI,mBAAmB,cAAc;AACnC,gBAAI,CAAC,UAAU,WAAW,MAAM,GAAG;AACjC,qBAAO;AAAA,YACT;AAAA,UACF;AACA,cAAI,mBAAmB,cAAc;AACnC,gBACE,CAAC,aAAa,aAAa,SAAS,CAAC,GAAG,MAAM,SAAS,MAAM,GAC7D;AACA,qBAAO;AAAA,YACT;AAAA,UACF;AAEA,cAAI,gBAAgB;AAAA,YAClB,UAAU,sBAAsB,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AAAA,UAAA;AAIrD,cAAI,UAAU,cAAc,WAAW,MAAM,GAAG;AAC9C,4BAAgB,cAAc,MAAM,OAAO,MAAM;AAAA,UACnD;AAEA,cAAI,UAAU,cAAc,SAAS,MAAM,GAAG;AAC5C,4BAAgB,cAAc;AAAA,cAC5B;AAAA,cACA,cAAc,SAAS,OAAO;AAAA,YAAA;AAAA,UAElC;AAEA,mBAAS;AAAA,QACX,OAAO;AAEL,mBAAS;AAAA,YACP,UAAU,sBAAsB,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AAAA,UAAA;AAAA,QAEvD;AAGA,eAAO,GAAG,IAAI;AACd,eAAO,QAAQ,IAAI;AACnB,eAAO;AAAA,MACT;AAEA,UAAI,aAAa,SAAS,uBAAuB;AAC/C,YAAI,aAAa,UAAU,OAAO,CAAC,aAAa,OAAO;AACrD;AACA;AAAA,QACF;AAEA,YAAI,aAAa;AACf,cAAI,eAAe;AACjB,gBAAI,aAAa,UAAU,YAAY,OAAO;AAC5C,qBAAO;AAAA,YACT;AAAA,UACF,WACE,aAAa,MAAM,YAAA,MAAkB,YAAY,MAAM,eACvD;AACA,mBAAO;AAAA,UACT;AACA;AACA;AACA;AAAA,QACF,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,aAAa,SAAS,oBAAoB;AAC5C,YAAI,CAAC,aAAa;AAChB,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,UAAU,KAAK;AAC7B,iBAAO;AAAA,QACT;AAEA,YAAI,cAAc;AAClB,YAAI,UAAU;AAGd,YAAI,aAAa,iBAAiB,aAAa,eAAe;AAC5D,gBAAM,SAAS,aAAa,iBAAiB;AAC7C,gBAAM,SAAS,aAAa,iBAAiB;AAG7C,gBAAM,YAAY,YAAY;AAC9B,cAAI,UAAU,CAAC,UAAU,WAAW,MAAM,GAAG;AAC3C,mBAAO;AAAA,UACT;AACA,cAAI,UAAU,CAAC,UAAU,SAAS,MAAM,GAAG;AACzC,mBAAO;AAAA,UACT;AAEA,cAAI,aAAa;AACjB,cAAI,UAAU,WAAW,WAAW,MAAM,GAAG;AAC3C,yBAAa,WAAW,MAAM,OAAO,MAAM;AAAA,UAC7C;AACA,cAAI,UAAU,WAAW,SAAS,MAAM,GAAG;AACzC,yBAAa,WAAW,MAAM,GAAG,WAAW,SAAS,OAAO,MAAM;AAAA,UACpE;AAEA,wBAAc,mBAAmB,UAAU;AAC3C,oBAAU;AAAA,QACZ,OAAO;AAEL,wBAAc,mBAAmB,YAAY,KAAK;AAClD,oBAAU;AAAA,QACZ;AAEA,YAAI,SAAS;AACX,iBAAO,aAAa,MAAM,UAAU,CAAC,CAAC,IAAI;AAC1C;AAAA,QACF;AAEA;AACA;AAAA,MACF;AAEA,UAAI,aAAa,SAAS,6BAA6B;AAErD,YAAI,CAAC,aAAa;AAEhB;AACA;AAAA,QACF;AAEA,YAAI,YAAY,UAAU,KAAK;AAE7B;AACA;AAAA,QACF;AAEA,YAAI,cAAc;AAClB,YAAI,UAAU;AAGd,YAAI,aAAa,iBAAiB,aAAa,eAAe;AAC5D,gBAAM,SAAS,aAAa,iBAAiB;AAC7C,gBAAM,SAAS,aAAa,iBAAiB;AAG7C,gBAAM,YAAY,YAAY;AAC9B,eACG,CAAC,UAAU,UAAU,WAAW,MAAM,OACtC,CAAC,UAAU,UAAU,SAAS,MAAM,IACrC;AACA,gBAAI,aAAa;AACjB,gBAAI,UAAU,WAAW,WAAW,MAAM,GAAG;AAC3C,2BAAa,WAAW,MAAM,OAAO,MAAM;AAAA,YAC7C;AACA,gBAAI,UAAU,WAAW,SAAS,MAAM,GAAG;AACzC,2BAAa,WAAW;AAAA,gBACtB;AAAA,gBACA,WAAW,SAAS,OAAO;AAAA,cAAA;AAAA,YAE/B;AAEA,0BAAc,mBAAmB,UAAU;AAC3C,sBAAU;AAAA,UACZ;AAAA,QACF,OAAO;AAKL,cAAI,sBAAsB;AAC1B,mBACM,YAAY,aAAa,GAC7B,YAAY,cAAc,QAC1B,aACA;AACA,kBAAM,qBAAqB,cAAc,SAAS;AAClD,gBACE,oBAAoB,SAAS,yBAC7B,mBAAmB,UAAU,YAAY,OACzC;AAGA,oCAAsB;AACtB;AAAA,YACF;AAGA,gBACE,oBAAoB,SAAS,sBAC7B,oBAAoB,SAAS,uBAC7B;AACA,kBAAI,aAAa,SAAS,cAAc,QAAQ;AAC9C,sCAAsB;AAAA,cACxB;AACA;AAAA,YACF;AAAA,UACF;AAEA,cAAI,qBAAqB;AAEvB,0BAAc,mBAAmB,YAAY,KAAK;AAClD,sBAAU;AAAA,UACZ;AAAA,QACF;AAEA,YAAI,SAAS;AACX,iBAAO,aAAa,MAAM,UAAU,CAAC,CAAC,IAAI;AAC1C;AAAA,QACF;AAEA;AACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,YAAY,aAAa,UAAU,cAAc,cAAc,QAAQ;AACzE,aAAO,IAAI,IAAI;AAAA,QACb,aAAa,MAAM,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK;AAAA,MAAA;AAElD,aAAO,CAAC,CAAC,SAAS,cAAc,cAAc,SAAS,CAAC,GAAG,UAAU;AAAA,IACvE;AAGA,QAAI,aAAa,cAAc,UAAU,aAAa,aAAa,QAAQ;AAEzE,eAAS,IAAI,YAAY,IAAI,cAAc,QAAQ,KAAK;AACtD,YAAI,cAAc,CAAC,GAAG,SAAS,6BAA6B;AAC1D,iBAAO;AAAA,QACT;AAAA,MACF;AAEA;AAAA,IACF;AAEA;AAAA,EACF;AAEA,SAAO;AACT;;;;;;;;;;;;;;;;;;;"}