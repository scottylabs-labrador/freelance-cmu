{"version":3,"file":"getRouteNodes.js","sources":["../../../../src/filesystem/virtual/getRouteNodes.ts"],"sourcesContent":["import path, { join, resolve } from 'node:path'\nimport {\n  removeExt,\n  removeLeadingSlash,\n  removeTrailingSlash,\n  replaceBackslash,\n  routePathToVariable,\n} from '../../utils'\nimport { getRouteNodes as getRouteNodesPhysical } from '../physical/getRouteNodes'\nimport { rootPathId } from '../physical/rootPathId'\nimport { virtualRootRouteSchema } from './config'\nimport { loadConfigFile } from './loadConfigFile'\nimport type {\n  VirtualRootRoute,\n  VirtualRouteNode,\n} from '@tanstack/virtual-file-routes'\nimport type { GetRouteNodesResult, RouteNode } from '../../types'\nimport type { Config } from '../../config'\n\nfunction ensureLeadingUnderScore(id: string) {\n  if (id.startsWith('_')) {\n    return id\n  }\n  return `_${id}`\n}\n\nfunction flattenTree(node: RouteNode): Array<RouteNode> {\n  const result = [node]\n\n  if (node.children) {\n    for (const child of node.children) {\n      result.push(...flattenTree(child))\n    }\n  }\n  delete node.children\n\n  return result\n}\n\nexport async function getRouteNodes(\n  tsrConfig: Pick<\n    Config,\n    | 'routesDirectory'\n    | 'virtualRouteConfig'\n    | 'routeFileIgnorePrefix'\n    | 'disableLogging'\n    | 'indexToken'\n    | 'routeToken'\n  >,\n  root: string,\n): Promise<GetRouteNodesResult> {\n  const fullDir = resolve(tsrConfig.routesDirectory)\n  if (tsrConfig.virtualRouteConfig === undefined) {\n    throw new Error(`virtualRouteConfig is undefined`)\n  }\n  let virtualRouteConfig: VirtualRootRoute\n  if (typeof tsrConfig.virtualRouteConfig === 'string') {\n    virtualRouteConfig = await getVirtualRouteConfigFromFileExport(\n      tsrConfig,\n      root,\n    )\n  } else {\n    virtualRouteConfig = tsrConfig.virtualRouteConfig\n  }\n  const { children, physicalDirectories } = await getRouteNodesRecursive(\n    tsrConfig,\n    root,\n    fullDir,\n    virtualRouteConfig.children,\n  )\n  const allNodes = flattenTree({\n    children,\n    filePath: virtualRouteConfig.file,\n    fullPath: replaceBackslash(join(fullDir, virtualRouteConfig.file)),\n    variableName: 'root',\n    routePath: `/${rootPathId}`,\n    _fsRouteType: '__root',\n  })\n\n  const rootRouteNode = allNodes[0]\n  const routeNodes = allNodes.slice(1)\n\n  return { rootRouteNode, routeNodes, physicalDirectories }\n}\n\n/**\n * Get the virtual route config from a file export\n *\n * @example\n * ```ts\n * // routes.ts\n * import { rootRoute } from '@tanstack/virtual-file-routes'\n *\n * export const routes = rootRoute({ ... })\n * // or\n * export default rootRoute({ ... })\n * ```\n *\n */\nasync function getVirtualRouteConfigFromFileExport(\n  tsrConfig: Pick<Config, 'virtualRouteConfig'>,\n  root: string,\n): Promise<VirtualRootRoute> {\n  if (\n    tsrConfig.virtualRouteConfig === undefined ||\n    typeof tsrConfig.virtualRouteConfig !== 'string' ||\n    tsrConfig.virtualRouteConfig === ''\n  ) {\n    throw new Error(`virtualRouteConfig is undefined or empty`)\n  }\n  const exports = await loadConfigFile(join(root, tsrConfig.virtualRouteConfig))\n\n  if (!('routes' in exports) && !('default' in exports)) {\n    throw new Error(\n      `routes not found in ${tsrConfig.virtualRouteConfig}. The routes export must be named like 'export const routes = ...' or done using 'export default ...'`,\n    )\n  }\n\n  const virtualRouteConfig =\n    'routes' in exports ? exports.routes : exports.default\n\n  return virtualRootRouteSchema.parse(virtualRouteConfig)\n}\n\nexport async function getRouteNodesRecursive(\n  tsrConfig: Pick<\n    Config,\n    | 'routesDirectory'\n    | 'routeFileIgnorePrefix'\n    | 'disableLogging'\n    | 'indexToken'\n    | 'routeToken'\n  >,\n  root: string,\n  fullDir: string,\n  nodes?: Array<VirtualRouteNode>,\n  parent?: RouteNode,\n): Promise<{ children: Array<RouteNode>; physicalDirectories: Array<string> }> {\n  if (nodes === undefined) {\n    return { children: [], physicalDirectories: [] }\n  }\n  const allPhysicalDirectories: Array<string> = []\n  const children = await Promise.all(\n    nodes.map(async (node) => {\n      if (node.type === 'physical') {\n        const { routeNodes, physicalDirectories } = await getRouteNodesPhysical(\n          {\n            ...tsrConfig,\n            routesDirectory: resolve(fullDir, node.directory),\n          },\n          root,\n        )\n        allPhysicalDirectories.push(node.directory)\n        routeNodes.forEach((subtreeNode) => {\n          subtreeNode.variableName = routePathToVariable(\n            `${node.pathPrefix}/${removeExt(subtreeNode.filePath)}`,\n          )\n          subtreeNode.routePath = `${parent?.routePath ?? ''}${node.pathPrefix}${subtreeNode.routePath}`\n          subtreeNode.filePath = `${node.directory}/${subtreeNode.filePath}`\n        })\n        return routeNodes\n      }\n\n      function getFile(file: string) {\n        const filePath = file\n        const variableName = routePathToVariable(removeExt(filePath))\n        const fullPath = replaceBackslash(join(fullDir, filePath))\n        return { filePath, variableName, fullPath }\n      }\n      const parentRoutePath = removeTrailingSlash(parent?.routePath ?? '/')\n\n      switch (node.type) {\n        case 'index': {\n          const { filePath, variableName, fullPath } = getFile(node.file)\n          const routePath = `${parentRoutePath}/`\n          return {\n            filePath,\n            fullPath,\n            variableName,\n            routePath,\n            _fsRouteType: 'static',\n          } satisfies RouteNode\n        }\n\n        case 'route': {\n          const lastSegment = node.path\n          let routeNode: RouteNode\n\n          const routePath = `${parentRoutePath}/${removeLeadingSlash(lastSegment)}`\n          if (node.file) {\n            const { filePath, variableName, fullPath } = getFile(node.file)\n            routeNode = {\n              filePath,\n              fullPath,\n              variableName,\n              routePath,\n              _fsRouteType: 'static',\n            }\n          } else {\n            routeNode = {\n              filePath: '',\n              fullPath: '',\n              variableName: routePathToVariable(routePath),\n              routePath,\n              isVirtual: true,\n              _fsRouteType: 'static',\n            }\n          }\n\n          if (node.children !== undefined) {\n            const { children, physicalDirectories } =\n              await getRouteNodesRecursive(\n                tsrConfig,\n                root,\n                fullDir,\n                node.children,\n                routeNode,\n              )\n            routeNode.children = children\n            allPhysicalDirectories.push(...physicalDirectories)\n\n            // If the route has children, it should be a layout\n            routeNode._fsRouteType = 'layout'\n          }\n          return routeNode\n        }\n        case 'layout': {\n          const { filePath, variableName, fullPath } = getFile(node.file)\n\n          if (node.id !== undefined) {\n            node.id = ensureLeadingUnderScore(node.id)\n          } else {\n            const baseName = path.basename(filePath)\n            const fileNameWithoutExt = path.parse(baseName).name\n            node.id = ensureLeadingUnderScore(fileNameWithoutExt)\n          }\n          const lastSegment = node.id\n          const routePath = `${parentRoutePath}/${removeLeadingSlash(lastSegment)}`\n\n          const routeNode: RouteNode = {\n            fullPath,\n            filePath,\n            variableName,\n            routePath,\n            _fsRouteType: 'pathless_layout',\n          }\n\n          if (node.children !== undefined) {\n            const { children, physicalDirectories } =\n              await getRouteNodesRecursive(\n                tsrConfig,\n                root,\n                fullDir,\n                node.children,\n                routeNode,\n              )\n            routeNode.children = children\n            allPhysicalDirectories.push(...physicalDirectories)\n          }\n          return routeNode\n        }\n      }\n    }),\n  )\n  return {\n    children: children.flat(),\n    physicalDirectories: allPhysicalDirectories,\n  }\n}\n"],"names":["getRouteNodesPhysical","children"],"mappings":"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"}