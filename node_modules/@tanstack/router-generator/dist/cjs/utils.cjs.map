{"version":3,"file":"utils.cjs","sources":["../../src/utils.ts"],"sourcesContent":["import * as fsp from 'node:fs/promises'\nimport path from 'node:path'\nimport * as prettier from 'prettier'\nimport { rootPathId } from './filesystem/physical/rootPathId'\nimport type { Config } from './config'\nimport type { ImportDeclaration, RouteNode } from './types'\n\nexport function multiSortBy<T>(\n  arr: Array<T>,\n  accessors: Array<(item: T) => any> = [(d) => d],\n): Array<T> {\n  return arr\n    .map((d, i) => [d, i] as const)\n    .sort(([a, ai], [b, bi]) => {\n      for (const accessor of accessors) {\n        const ao = accessor(a)\n        const bo = accessor(b)\n\n        if (typeof ao === 'undefined') {\n          if (typeof bo === 'undefined') {\n            continue\n          }\n          return 1\n        }\n\n        if (ao === bo) {\n          continue\n        }\n\n        return ao > bo ? 1 : -1\n      }\n\n      return ai - bi\n    })\n    .map(([d]) => d)\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function removeLeadingSlash(path: string): string {\n  return path.replace(/^\\//, '')\n}\n\nexport function removeTrailingSlash(s: string) {\n  return s.replace(/\\/$/, '')\n}\n\nconst BRACKET_CONTENT_RE = /\\[(.*?)\\]/g\n\nexport function determineInitialRoutePath(routePath: string) {\n  const DISALLOWED_ESCAPE_CHARS = new Set([\n    '/',\n    '\\\\',\n    '?',\n    '#',\n    ':',\n    '*',\n    '<',\n    '>',\n    '|',\n    '!',\n    '$',\n    '%',\n  ])\n\n  const parts = routePath.split(/(?<!\\[)\\.(?!\\])/g)\n\n  // Escape any characters that in square brackets\n  const escapedParts = parts.map((part) => {\n    // Check if any disallowed characters are used in brackets\n\n    let match\n    while ((match = BRACKET_CONTENT_RE.exec(part)) !== null) {\n      const character = match[1]\n      if (character === undefined) continue\n      if (DISALLOWED_ESCAPE_CHARS.has(character)) {\n        console.error(\n          `Error: Disallowed character \"${character}\" found in square brackets in route path \"${routePath}\".\\nYou cannot use any of the following characters in square brackets: ${Array.from(\n            DISALLOWED_ESCAPE_CHARS,\n          ).join(', ')}\\nPlease remove and/or replace them.`,\n        )\n        process.exit(1)\n      }\n    }\n\n    // Since this split segment is safe at this point, we can\n    // remove the brackets and replace them with the content inside\n    return part.replace(BRACKET_CONTENT_RE, '$1')\n  })\n\n  // If the syntax for prefix/suffix is different, from the path\n  // matching internals of router-core, we'd perform those changes here\n  // on the `escapedParts` array before it is joined back together in\n  // `final`\n\n  const final = cleanPath(`/${escapedParts.join('/')}`) || ''\n\n  return final\n}\n\nexport function replaceBackslash(s: string) {\n  return s.replaceAll(/\\\\/gi, '/')\n}\n\nexport function routePathToVariable(routePath: string): string {\n  const toVariableSafeChar = (char: string): string => {\n    if (/[a-zA-Z0-9_]/.test(char)) {\n      return char // Keep alphanumeric characters and underscores as is\n    }\n\n    // Replace special characters with meaningful text equivalents\n    switch (char) {\n      case '.':\n        return 'Dot'\n      case '-':\n        return 'Dash'\n      case '@':\n        return 'At'\n      case '(':\n        return '' // Removed since route groups use parentheses\n      case ')':\n        return '' // Removed since route groups use parentheses\n      case ' ':\n        return '' // Remove spaces\n      default:\n        return `Char${char.charCodeAt(0)}` // For any other characters\n    }\n  }\n\n  return (\n    removeUnderscores(routePath)\n      ?.replace(/\\/\\$\\//g, '/splat/')\n      .replace(/\\$$/g, 'splat')\n      .replace(/\\$\\{\\$\\}/g, 'splat')\n      .replace(/\\$/g, '')\n      .split(/[/-]/g)\n      .map((d, i) => (i > 0 ? capitalize(d) : d))\n      .join('')\n      .split('')\n      .map(toVariableSafeChar)\n      .join('')\n      // .replace(/([^a-zA-Z0-9]|[.])/gm, '')\n      .replace(/^(\\d)/g, 'R$1') ?? ''\n  )\n}\n\nexport function removeUnderscores(s?: string) {\n  return s?.replaceAll(/(^_|_$)/gi, '').replaceAll(/(\\/_|_\\/)/gi, '/')\n}\n\nexport function capitalize(s: string) {\n  if (typeof s !== 'string') return ''\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport function removeExt(d: string, keepExtension: boolean = false) {\n  return keepExtension ? d : d.substring(0, d.lastIndexOf('.')) || d\n}\n\n/**\n * This function writes to a file if the content is different.\n *\n * @param filepath The path to the file\n * @param content Original content\n * @param incomingContent New content\n * @param callbacks Callbacks to run before and after writing\n * @returns Whether the file was written\n */\nexport async function writeIfDifferent(\n  filepath: string,\n  content: string,\n  incomingContent: string,\n  callbacks?: { beforeWrite?: () => void; afterWrite?: () => void },\n): Promise<boolean> {\n  if (content !== incomingContent) {\n    callbacks?.beforeWrite?.()\n    await fsp.writeFile(filepath, incomingContent)\n    callbacks?.afterWrite?.()\n    return true\n  }\n  return false\n}\n\n/**\n * This function formats the source code using the default formatter (Prettier).\n *\n * @param source The content to format\n * @param config The configuration object\n * @returns The formatted content\n */\nexport async function format(\n  source: string,\n  config: {\n    quoteStyle: 'single' | 'double'\n    semicolons: boolean\n  },\n): Promise<string> {\n  const prettierOptions: prettier.Config = {\n    semi: config.semicolons,\n    singleQuote: config.quoteStyle === 'single',\n    parser: 'typescript',\n  }\n  return prettier.format(source, prettierOptions)\n}\n\n/**\n * This function resets the regex index to 0 so that it can be reused\n * without having to create a new regex object or worry about the last\n * state when using the global flag.\n *\n * @param regex The regex object to reset\n * @returns\n */\nexport function resetRegex(regex: RegExp) {\n  regex.lastIndex = 0\n  return\n}\n\n/**\n * This function checks if a file exists.\n *\n * @param file The path to the file\n * @returns Whether the file exists\n */\nexport async function checkFileExists(file: string) {\n  try {\n    await fsp.access(file, fsp.constants.F_OK)\n    return true\n  } catch {\n    return false\n  }\n}\n\nconst possiblyNestedRouteGroupPatternRegex = /\\([^/]+\\)\\/?/g\nexport function removeGroups(s: string) {\n  return s.replace(possiblyNestedRouteGroupPatternRegex, '')\n}\n\n/**\n * Removes all segments from a given path that start with an underscore ('_').\n *\n * @param {string} routePath - The path from which to remove segments. Defaults to '/'.\n * @returns {string} The path with all underscore-prefixed segments removed.\n * @example\n * removeLayoutSegments('/workspace/_auth/foo') // '/workspace/foo'\n */\nexport function removeLayoutSegments(routePath: string = '/'): string {\n  const segments = routePath.split('/')\n  const newSegments = segments.filter((segment) => !segment.startsWith('_'))\n  return newSegments.join('/')\n}\n\n/**\n * The `node.path` is used as the `id` in the route definition.\n * This function checks if the given node has a parent and if so, it determines the correct path for the given node.\n * @param node - The node to determine the path for.\n * @returns The correct path for the given node.\n */\nexport function determineNodePath(node: RouteNode) {\n  return (node.path = node.parent\n    ? node.routePath?.replace(node.parent.routePath ?? '', '') || '/'\n    : node.routePath)\n}\n\n/**\n * Removes the last segment from a given path. Segments are considered to be separated by a '/'.\n *\n * @param {string} routePath - The path from which to remove the last segment. Defaults to '/'.\n * @returns {string} The path with the last segment removed.\n * @example\n * removeLastSegmentFromPath('/workspace/_auth/foo') // '/workspace/_auth'\n */\nexport function removeLastSegmentFromPath(routePath: string = '/'): string {\n  const segments = routePath.split('/')\n  segments.pop() // Remove the last segment\n  return segments.join('/')\n}\n\nexport function hasParentRoute(\n  routes: Array<RouteNode>,\n  node: RouteNode,\n  routePathToCheck: string | undefined,\n): RouteNode | null {\n  if (!routePathToCheck || routePathToCheck === '/') {\n    return null\n  }\n\n  const sortedNodes = multiSortBy(routes, [\n    (d) => d.routePath!.length * -1,\n    (d) => d.variableName,\n  ]).filter((d) => d.routePath !== `/${rootPathId}`)\n\n  for (const route of sortedNodes) {\n    if (route.routePath === '/') continue\n\n    if (\n      routePathToCheck.startsWith(`${route.routePath}/`) &&\n      route.routePath !== routePathToCheck\n    ) {\n      return route\n    }\n  }\n\n  const segments = routePathToCheck.split('/')\n  segments.pop() // Remove the last segment\n  const parentRoutePath = segments.join('/')\n\n  return hasParentRoute(routes, node, parentRoutePath)\n}\n\n/**\n * Gets the final variable name for a route\n */\nexport const getResolvedRouteNodeVariableName = (\n  routeNode: RouteNode,\n): string => {\n  return routeNode.children?.length\n    ? `${routeNode.variableName}RouteWithChildren`\n    : `${routeNode.variableName}Route`\n}\n\n/**\n * Checks if a given RouteNode is valid for augmenting it with typing based on conditions.\n * Also asserts that the RouteNode is defined.\n *\n * @param routeNode - The RouteNode to check.\n * @returns A boolean indicating whether the RouteNode is defined.\n */\nexport function isRouteNodeValidForAugmentation(\n  routeNode?: RouteNode,\n): routeNode is RouteNode {\n  if (!routeNode || routeNode.isVirtual) {\n    return false\n  }\n  return true\n}\n\n/**\n * Infers the path for use by TS\n */\nexport const inferPath = (routeNode: RouteNode): string => {\n  return routeNode.cleanedPath === '/'\n    ? routeNode.cleanedPath\n    : (routeNode.cleanedPath?.replace(/\\/$/, '') ?? '')\n}\n\n/**\n * Infers the full path for use by TS\n */\nexport const inferFullPath = (routeNode: RouteNode): string => {\n  const fullPath = removeGroups(\n    removeUnderscores(removeLayoutSegments(routeNode.routePath)) ?? '',\n  )\n\n  return routeNode.cleanedPath === '/' ? fullPath : fullPath.replace(/\\/$/, '')\n}\n\n/**\n * Creates a map from fullPath to routeNode\n */\nexport const createRouteNodesByFullPath = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    routeNodes.map((routeNode) => [inferFullPath(routeNode), routeNode]),\n  )\n}\n\n/**\n * Create a map from 'to' to a routeNode\n */\nexport const createRouteNodesByTo = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    dedupeBranchesAndIndexRoutes(routeNodes).map((routeNode) => [\n      inferTo(routeNode),\n      routeNode,\n    ]),\n  )\n}\n\n/**\n * Create a map from 'id' to a routeNode\n */\nexport const createRouteNodesById = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    routeNodes.map((routeNode) => {\n      const id = routeNode.routePath ?? ''\n      return [id, routeNode]\n    }),\n  )\n}\n\n/**\n * Infers to path\n */\nexport const inferTo = (routeNode: RouteNode): string => {\n  const fullPath = inferFullPath(routeNode)\n\n  if (fullPath === '/') return fullPath\n\n  return fullPath.replace(/\\/$/, '')\n}\n\n/**\n * Dedupes branches and index routes\n */\nexport const dedupeBranchesAndIndexRoutes = (\n  routes: Array<RouteNode>,\n): Array<RouteNode> => {\n  return routes.filter((route) => {\n    if (route.children?.find((child) => child.cleanedPath === '/')) return false\n    return true\n  })\n}\n\nfunction checkUnique<TElement>(routes: Array<TElement>, key: keyof TElement) {\n  // Check no two routes have the same `key`\n  // if they do, throw an error with the conflicting filePaths\n  const keys = routes.map((d) => d[key])\n  const uniqueKeys = new Set(keys)\n  if (keys.length !== uniqueKeys.size) {\n    const duplicateKeys = keys.filter((d, i) => keys.indexOf(d) !== i)\n    const conflictingFiles = routes.filter((d) =>\n      duplicateKeys.includes(d[key]),\n    )\n    return conflictingFiles\n  }\n  return undefined\n}\n\nexport function checkRouteFullPathUniqueness(\n  _routes: Array<RouteNode>,\n  config: Config,\n) {\n  const routes = _routes.map((d) => {\n    const inferredFullPath = inferFullPath(d)\n    return { ...d, inferredFullPath }\n  })\n\n  const conflictingFiles = checkUnique(routes, 'inferredFullPath')\n\n  if (conflictingFiles !== undefined) {\n    const errorMessage = `Conflicting configuration paths were found for the following route${conflictingFiles.length > 1 ? 's' : ''}: ${conflictingFiles\n      .map((p) => `\"${p.inferredFullPath}\"`)\n      .join(', ')}.\nPlease ensure each Route has a unique full path.\nConflicting files: \\n ${conflictingFiles.map((d) => path.resolve(config.routesDirectory, d.filePath)).join('\\n ')}\\n`\n    throw new Error(errorMessage)\n  }\n}\n\nexport function buildRouteTreeConfig(\n  nodes: Array<RouteNode>,\n  disableTypes: boolean,\n  depth = 1,\n): Array<string> {\n  const children = nodes.map((node) => {\n    if (node._fsRouteType === '__root') {\n      return\n    }\n\n    if (node._fsRouteType === 'pathless_layout' && !node.children?.length) {\n      return\n    }\n\n    const route = `${node.variableName}`\n\n    if (node.children?.length) {\n      const childConfigs = buildRouteTreeConfig(\n        node.children,\n        disableTypes,\n        depth + 1,\n      )\n\n      const childrenDeclaration = disableTypes\n        ? ''\n        : `interface ${route}RouteChildren {\n  ${node.children\n    .map(\n      (child) =>\n        `${child.variableName}Route: typeof ${getResolvedRouteNodeVariableName(child)}`,\n    )\n    .join(',')}\n}`\n\n      const children = `const ${route}RouteChildren${disableTypes ? '' : `: ${route}RouteChildren`} = {\n  ${node.children\n    .map(\n      (child) =>\n        `${child.variableName}Route: ${getResolvedRouteNodeVariableName(child)}`,\n    )\n    .join(',')}\n}`\n\n      const routeWithChildren = `const ${route}RouteWithChildren = ${route}Route._addFileChildren(${route}RouteChildren)`\n\n      return [\n        childConfigs.join('\\n'),\n        childrenDeclaration,\n        children,\n        routeWithChildren,\n      ].join('\\n\\n')\n    }\n\n    return undefined\n  })\n\n  return children.filter((x) => x !== undefined)\n}\n\nexport function buildImportString(\n  importDeclaration: ImportDeclaration,\n): string {\n  const { source, specifiers, importKind } = importDeclaration\n  return specifiers.length\n    ? `import ${importKind === 'type' ? 'type ' : ''}{ ${specifiers.map((s) => (s.local ? `${s.imported} as ${s.local}` : s.imported)).join(', ')} } from '${source}'`\n    : ''\n}\n\nexport function lowerCaseFirstChar(value: string) {\n  if (!value[0]) {\n    return value\n  }\n\n  return value[0].toLowerCase() + value.slice(1)\n}\n\nexport function mergeImportDeclarations(\n  imports: Array<ImportDeclaration>,\n): Array<ImportDeclaration> {\n  const merged: Record<string, ImportDeclaration> = {}\n\n  for (const imp of imports) {\n    const key = `${imp.source}-${imp.importKind}`\n    if (!merged[key]) {\n      merged[key] = { ...imp, specifiers: [] }\n    }\n    for (const specifier of imp.specifiers) {\n      // check if the specifier already exists in the merged import\n      if (\n        !merged[key].specifiers.some(\n          (existing) =>\n            existing.imported === specifier.imported &&\n            existing.local === specifier.local,\n        )\n      ) {\n        merged[key].specifiers.push(specifier)\n      }\n    }\n  }\n\n  return Object.values(merged)\n}\n\nexport const findParent = (node: RouteNode | undefined): string => {\n  if (!node) {\n    return `rootRouteImport`\n  }\n  if (node.parent) {\n    if (node.isVirtualParentRequired) {\n      return `${node.parent.variableName}Route`\n    } else {\n      return `${node.parent.variableName}Route`\n    }\n  }\n  return findParent(node.parent)\n}\n\nexport function buildFileRoutesByPathInterface(opts: {\n  routeNodes: Array<RouteNode>\n  module: string\n  interfaceName: string\n}): string {\n  return `declare module '${opts.module}' {\n  interface ${opts.interfaceName} {\n    ${opts.routeNodes\n      .map((routeNode) => {\n        const filePathId = routeNode.routePath\n        const preloaderRoute = `typeof ${routeNode.variableName}RouteImport`\n\n        const parent = findParent(routeNode)\n\n        return `'${filePathId}': {\n          id: '${filePathId}'\n          path: '${inferPath(routeNode)}'\n          fullPath: '${inferFullPath(routeNode)}'\n          preLoaderRoute: ${preloaderRoute}\n          parentRoute: typeof ${parent}\n        }`\n      })\n      .join('\\n')}\n  }\n}`\n}\n\nexport function getImportPath(\n  node: RouteNode,\n  config: Config,\n  generatedRouteTreePath: string,\n): string {\n  return replaceBackslash(\n    removeExt(\n      path.relative(\n        path.dirname(generatedRouteTreePath),\n        path.resolve(config.routesDirectory, node.filePath),\n      ),\n      config.addExtensions,\n    ),\n  )\n}\n\nexport function getImportForRouteNode(\n  node: RouteNode,\n  config: Config,\n  generatedRouteTreePath: string,\n  root: string,\n): ImportDeclaration {\n  let source = ''\n  if (config.importRoutesUsingAbsolutePaths) {\n    source = replaceBackslash(\n      removeExt(\n        path.resolve(root, config.routesDirectory, node.filePath),\n        config.addExtensions,\n      ),\n    )\n  } else {\n    source = `./${getImportPath(node, config, generatedRouteTreePath)}`\n  }\n  return {\n    source,\n    specifiers: [\n      {\n        imported: 'Route',\n        local: `${node.variableName}RouteImport`,\n      },\n    ],\n  } satisfies ImportDeclaration\n}\n"],"names":["path","fsp","prettier","rootPathId","children"],"mappings":"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"}